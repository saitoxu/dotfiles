package adauction.simulator;

import java.util.ArrayList;

public class DSP {
    private static final int quota = 1000; // 変動量の上限値
    private static final int step = 1000; // stepの間価格がrange以内だったら収束
    private static final double range = 0.0005;

    // 引数にSTRUCTの数と広告枠の数を取る
    public static void main(String[] args) {
        // シミュレーションに使用するSTRUCTと広告枠
        // 現在は直接編集しなければならない
        // TODO csvファイルに書き込み，それを読み込んで実行するようにする
        ArrayList<Integer> structNum = new ArrayList<Integer>();
        ArrayList<Integer> adSpaceNum = new ArrayList<Integer>();
        ArrayList<Struct> struct = new ArrayList<Struct>();
        ArrayList<AdSpace> adSpace = new ArrayList<AdSpace>();
        // DSPは各広告枠の現在の価格を把握している
        ArrayList<Double> currentPrices = new ArrayList<Double>();
        // 同じく各広告枠の入札額とインプレッションの関係も知っている
        ArrayList<ArrayList<Value>> curves = new ArrayList<ArrayList<Value>>();
        // シミュレーションに参加していないSTRUCTが各広告枠で獲得したインプレッション数の和
        ArrayList<Integer> otherSum = new ArrayList<Integer>();

        // 広告枠をランダムに選択
        adSpaceNum = FileReader.selectAdSpaces(Integer.parseInt(args[1]));
        // STRUCTをランダムに選択
        // 広告枠に合わせて予算が0にならないようにする
        // 必ず広告枠を先に決める
        structNum = FileReader.selectStructs(Integer.parseInt(args[0]), adSpaceNum);

        System.out.println(structNum); // STRUCT表示
        System.out.println(adSpaceNum); // 広告枠表示

        // STRUCTの初期化
        for (int _struct : structNum) {
            struct.add(new Struct(FileReader.readBudget(_struct, adSpaceNum),
                                  FileReader.readCpa(_struct), FileReader.readIcvr(_struct,
                                                                                   adSpaceNum)));
        }

        // 他のSTRUCTのインプレッション数の和を計算
        for (int _adSpaceNum : adSpaceNum) {
            otherSum.add(FileReader.readOtherSum(_adSpaceNum, structNum));
        }

        // 広告枠の初期化
        for (int i = 0; i < adSpaceNum.size(); i++) {
            adSpace.add(new AdSpace(FileReader.readCurveFile(adSpaceNum.get(i),
                                                             otherSum.get(i))));
        }

        // 各広告枠の入札額とインプレッションの関係をSET + 初期価格の周知
        for (AdSpace _adSpace : adSpace) {
            curves.add(_adSpace.getCurve());
            currentPrices.add(_adSpace.getCurrentPrice());
        }

        int[][] imps = new int[struct.size()][adSpace.size()]; // インプレッション数
        ArrayList<ArrayList<Double>> pastPrices = new ArrayList<ArrayList<Double>>(); // 過去の価格を記憶

        // 初期化
        for (int[] imp : imps) {
            for (int j : imp) {
                imp[j] = 0;
            }
        }

        for (int k = 0; k < 100000; k++) {
            System.out.println("No." + (k + 1));
            // 価格を表示
            System.out.println(currentPrices);
            // 現在の価格を過去の価格系列に追加
            pastPrices = addPrices(pastPrices, currentPrices);

            for (int i = 0; i < struct.size(); i++) {
                ArrayList<Integer> temp = struct.get(i).getDemandOnPrice(quota,
                                                                         imps[i], currentPrices);
                for (int j = 0; j < temp.size(); j++) {
                    imps[i][j] = temp.get(j);
                }
            }

            for (int[] imp : imps) {
                for (int _imp : imp) {
                    // System.out.print(_imp + ",");
                    System.out.printf("%7d", _imp);
                }
                System.out.println();
            }

            // 価格を更新
            currentPrices = updatePrices(adSpace, currentPrices, imps);

            System.out.println();

            // 収束条件を満たしたらループから抜けて終了する
            if (isConvergent(pastPrices)) {
                System.out.println("SUCCESS");
                break;
            }
        }
        System.out.println(structNum); // STRUCT表示
        System.out.println(adSpaceNum); // 広告枠表示

        System.out.printf("\n--- the number of impressions in simulation ---\n");
        for (int[] imp : imps) {
            for (int _imp : imp) {
                // System.out.print(_imp + ",");
                System.out.printf("%7d", _imp);
            }
            System.out.println();
        }

        // 実際のインプレッション数を計算して表示する
        System.out.printf("\n--- the number of impressions in real ---\n");
        ArrayList<ArrayList<Integer>> realImps = FileReader.getRealImpressions(structNum, adSpaceNum);
        for (ArrayList<Integer> _imps : realImps) {
            for (int _imp : _imps) {
                System.out.printf("%7d", _imp);
            }
            System.out.println();
        }

        System.out.println();

        System.out.printf("\n--- the number of conversions in simulation ---\n");
        for (int _i = 0; _i < struct.size(); _i++) {
            for (int _j = 0; _j < adSpace.size(); _j++) {
                // 1000倍表示にして見やすく
                // icvrがない場合は表示しない
                if (struct.get(_i).getIcvr().get(_j) != 1) {
                    System.out.printf("%7d", (int)(imps[_i][_j] * struct.get(_i).getIcvr().get(_j) * 1000));
                } else {
                    System.out.printf("      -");
                }
            }
            System.out.println();
        }

        System.out.printf("\n--- the number of conversions in real ---\n");
        for (int _i = 0; _i < struct.size(); _i++) {
            for (int _j = 0; _j < adSpace.size(); _j++) {
                if (struct.get(_i).getIcvr().get(_j) != 1) {
                    System.out.printf("%7d", (int)(realImps.get(_i).get(_j) * struct.get(_i).getIcvr().get(_j) * 1000));
                } else {
                    System.out.printf("      -");
                }
            }
            System.out.println();
        }

        // シミュレーション終了
        System.exit(0);
    }

    // 価格を更新する
    private static ArrayList<Double> updatePrices(ArrayList<AdSpace> adSpace,
                                                  ArrayList<Double> currentPrices, int[][] imps) {
        ArrayList<Double> nextPrices = new ArrayList<Double>();
        ArrayList<Integer> sum = new ArrayList<Integer>();

        for (int i = 0; i < imps[0].length; i++) {
            int temp = 0;
            for (int j = 0; j < imps.length; j++) {
                temp += imps[j][i];
            }
            sum.add(temp);
        }

        for (int i = 0; i < adSpace.size(); i++) {
            nextPrices.add(adSpace.get(i).getNextPrice(currentPrices.get(i),
                                                       sum.get(i)));
        }

        return nextPrices;
    }

    // 現在の価格を過去の価格系列に追加
    private static ArrayList<ArrayList<Double>> addPrices(ArrayList<ArrayList<Double>> pastPrices, ArrayList<Double> currentPrices) {
        // 初め
        if (pastPrices.isEmpty()) {
            for (int i = 0; i < currentPrices.size(); i++) {
                pastPrices.add(new ArrayList<Double>());
            }
        }
        // 現在価格を追加
        for (int i = 0; i < currentPrices.size(); i++) {
            pastPrices.get(i).add(currentPrices.get(i));
        }
        // 1000超えたら最初の価格を削除
        if (pastPrices.get(0).size() > 1000) {
            for (int i = 0; i < pastPrices.size(); i++) {
                pastPrices.get(i).remove(0);
            }
        }

        return pastPrices;
    }

    // 収束条件を満たしているか
    private static boolean isConvergent(ArrayList<ArrayList<Double>> pastPrices) {
        // 1000ステップに達してなかったらfalse
        if (pastPrices.get(0).size() < 1000) {
            return false;
        }
        // 現在価格との絶対値がrange以上だったらfalse
        for (ArrayList<Double> pastPrice : pastPrices) {
            for (int i = 0; i < pastPrice.size(); i++) {
                if (Math.abs(pastPrice.get(i) - pastPrice.get(pastPrice.size() - 1)) >= range) {
                    return false;
                }
            }
        }
        return true;
    }
}
